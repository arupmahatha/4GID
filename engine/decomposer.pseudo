Class QueryDecomposer:
    Note: Initialize the local LLM through llm_call.py

    Function decompose_complex_query(query):
        /*
        Purpose: Break down complex queries into specific sub-queries
        */
         1. Create a prompt for the LLM (utilizing 2-shot learning) to analyze query complexity
         2. If the query is simple:
             Return the original query as a single item list
         3. If the query is complex:
             - Utilize the LLM to break it into focused sub-queries
             - Extract sub-queries from the LLM response
             - Return a list of sub-queries
         4. On error: Return the original query as a fallback

    Function select_relevant_table(query):
        /*
        Purpose: Select the most appropriate table for a given query
        */
         1. Create a prompt for the LLM to select the most appropriate table for the given query
         2. Retrieve all table names from metadata.py
         3. Return the most relevant table for the specific query as a string

    Function extract_entities(query):
        /*
        Purpose: Extract entities from the query, such as place names and other relevant information
        */
         1. Employ LLM logic (create a prompt, utilizing 2-shot learning) to extract and return them as a list for the given query

    Function match_entities(entity, table_name):
        /*
        Purpose: Find and map the entity to the table_name
        */
         1. Utilize search.py functionality to find matches
         2. Format each match with:
             - Search term
             - Column name
             - Matched value
             - Match score
         3. Return formatted matches
         4. On error: Return an empty list

    Function main_decomposer(query):
        /*
        Main function to process the entire decomposer pipeline
        */
         1. Call the decompose_complex_query function
         2. For each sub-query:
             a. Select the relevant table using select_relevant_table
             b. Extract entities using extract_entities
             c. For each entity:
                 Perform mapping using match_entities
             d. Create a result dictionary with:
                 - Query type (direct/decomposed)
                 - If not direct, then Sub-query number and Sub-query text; if direct, then query text
                 - Table selected to answer the query and columns in the table, formatted as table_name : ['column1', 'column2']
                 - Extracted entities
                 - Matching results
         3. Return a list of results
         4. On error: Return error information